# Segment Tree
Segment Tree

**参考学习资料**
>
http://www.cse.iitk.ac.in/users/aca/lop12/slides/06.pdf

讲解线段树的视屏。
>
https://www.youtube.com/watch?v=GLuT4zKzdjc

## 线段树的适用场景

考虑以下问题来理解线段树。有一个[0...n-1]的数组，现有一些的操作：

	1) 查询：求 下标从 l 到 r ( 0 <= l <= r <= n-1) 区间内所有元素的和
	2) 更新：更新数组中任一个元素的值

最直接的解法方法是执行一个循环，求得l到r的总和。更新的话就很简单了，直接操作。
时间复杂度分别为:

	1) 查询：O(n)
	2) 更新：O(1)


另一中解法方法是：创建另一个数组sumarr[], 存储从第一个元素到第i个的总和。例如sumarr[3]表示[0...3]区间内元素的总和。如果查询的次数远多于更新的次数，可以用这种方法。现在两个操作的时间复杂度为分别为：O(1)和O(n)。

	1) 查询：O(1)
	2) 更新：O(n)

如果查询和更新的操作数量是相等的呢？这时可以用线段树来解决，两个操作都在O（logN）时间内。
	
	1) 查询：O(logN)
	2) 更新：O(logN)

## 线段树的表示

线段树（Segment Tree）是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

1. 页节点即输入数组的所有元素
2. 内部节点表示的是部分合并的叶节点.  (合并的方式需要根据不同的问题，对于这个问题，合并就是求和.)

![图1](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree1.png)

## 如何构造线段树对于给定的数组？

我们从arr[0 ...n-1]开始，每次我们将当前数组段分为两半(如果长度大于1), 然后递归调用者两半, 并存储这两个子区间的总和。

可以发现,树将是满二叉树,因为我们在每一层，都是把区间分为两个部分。

由于树总的叶子节点为n,因此有 n – 1个 内部节点。因此节点总数为2*n – 1,树的高度为 log(n).由于这是一个满二叉树，而每一个节点存储的元素都是单一的值。因此完全可以用数组可以模拟二叉树，而不是构成传统的二叉树。

对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。



**时间复杂度分析**

树的构建复杂度为 O(n)，因为树的节点总数位 2n-1个，每个节点只会被计算一次。

查询和更新的操作都为O(Logn)， 由树的高度决定。


		
		