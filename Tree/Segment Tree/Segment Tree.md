# Segment Tree
Segment Tree

**参考学习资料**
>
http://www.cse.iitk.ac.in/users/aca/lop12/slides/06.pdf

讲解线段树的视屏。
>
https://www.youtube.com/watch?v=GLuT4zKzdjc

## 线段树的适用场景

考虑以下问题来理解线段树。有一个[0...n-1]的数组，现有一些的操作：

	1) 查询：求 下标从 l 到 r ( 0 <= l <= r <= n-1) 区间内所有元素的和
	2) 更新：更新数组中任一个元素的值

最直接的解法方法是执行一个循环，求得l到r的总和。更新的话就很简单了，直接操作。
时间复杂度分别为:

	1) 查询：O(n)
	2) 更新：O(1)


另一中解法方法是：创建另一个数组sumarr[], 存储从第一个元素到第i个的总和。例如sumarr[3]表示[0...3]区间内元素的总和。如果查询的次数远多于更新的次数，可以用这种方法。现在两个操作的时间复杂度为分别为：O(1)和O(n)。

	1) 查询：O(1)
	2) 更新：O(n)

如果查询和更新的操作数量是相等的呢？这时可以用线段树来解决，两个操作都在O（logN）时间内。
	
	1) 查询：O(logN)
	2) 更新：O(logN)

## 线段树的表示

线段树（Segment Tree）是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

1. 页节点即输入数组的所有元素
2. 内部节点表示的是部分合并的叶节点.  (合并的方式需要根据不同的问题，对于这个问题，合并就是求和.)

![图1](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree1.png)

## 如何构造线段树对于给定的数组？

我们从arr[0 ...n-1]开始，每次我们将当前数组段分为两半(如果长度大于1), 然后递归调用者两半, 并存储这两个子区间的总和。

可以发现,树将是满二叉树,因为我们在每一层，都是把区间分为两个部分。

由于树总的叶子节点为n,因此有 n – 1个 内部节点。因此节点总数为2*n – 1,树的高度为 log(n).由于这是一个满二叉树，而每一个节点存储的元素都是单一的值。因此完全可以用数组可以模拟二叉树，而不是构成传统的二叉树。

对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。



**时间复杂度分析**

树的构建复杂度为 O(n)，因为树的节点总数位 2n-1个，每个节点只会被计算一次。

查询和更新的操作都为O(Logn)， 由树的高度决定。


## 例题分析

例题：给定N条线段，{[2, 5], [4, 6], [0, 7]}, M个点{2, 4, 7},判断每个点分别在几条线段出现过？

**解法1**

最简单的解法，就是对每个点分别遍历n条线段，看每个点是否在线段内，时间复杂度为O(n * m)。这种做法简单，但是对于每一次查询，都需要遍历n条线段。因此我们想到，是不是可以对n条线段进行预处理，然后每次查询只需要利用预处理后的更少的数据(小于n)，而不需要原来的n条数据。

**解法2**

事实上，我们可以用一个数组count[0 ... n]，count[i]表示第i个点出现在线段的次数。然后根据以下过程：

	初始时：    [0, 0, 0, 0, 0, 0, 0, 0]
	插入[2,5]:  [0, 0, 1, 1, 1, 1, 0, 0]
	插入[4,6]:  [0, 0, 1, 1, 2, 2, 1, 0]
	插入[0,7]:  [1, 1, 2, 2, 3, 3, 2, 1]

即每次插入一条线段时，就将该线段的所有点的次数加1,这样查询时只要直接根据count[i]就可以确定点i出现在线段的次数，查询时间复杂度是O(1)。插入一条线段的时间复杂度取决于线段的长度，例如插入n条[0, n]的线段，时间复杂度为O(n^2)，显然插入的时间复杂度不令人满意。

**解法3（线段树解法）**

如何优化插入线段的时间？这时候就可以利用线段树来批量更新区间的信息。

首先，我们给线段树的每个节点增加一个count成员来记录该节点所表示线段出现的次数。然后将所有线段依次插入。对要插入的线段A从根节点开始遍历，有以下4种情况：

线段A刚好与节点所表示线段完全重合，将该节点count + 1，返回;
线段A在节点的左半区间，则从该节点的左儿子开始递归遍历;
线段A在节点的右半区间，则从该节点的右儿子开始递归遍历;
线段A横跨节点的左右半区间，将线段A分成2段，左半段从该节点的左儿子开始遍历，右半段从该节点的右儿子开始遍历。

1、构建线段树

![图2](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree2.png)		

2、处理线段

三条线段分割之后		

![图3](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree3.png)

这样插入n条线段的平均时间为O(nlgn)。

3、查询

而查询的时候，只需要将包含查询点的节点的count值相加即可，查询的时间复杂度为O(lgn)。例如查询点2，只需要将【0,7】,【0,3】,【2,3】,【2,2】相加得到2。

对于每一个值我们就可以开始遍历这一颗线段树，加上对于结点的count字段便是在线段中出现的次数

比如对于4，首先遍历[0, 7]，次数 = 0+1=1；4在右半区间，遍历[4, 7],次数 = 1+0=0;4在[4, 7]左半区间, 次数 = 1+2=3;4在[4, 5]左半区间,次数 = 3+0 = 4，遍历结束，次数 = 3说明4在三条线段中出现过,同理可求其他的值，这一步的时间复杂度为O(M*log(MAX-MIN))

## 部分总结

涉及到区间的信息更新或查询时我们通常可以使用线段树来优化，例如上面插入线段[0,7]时只需要简单将节点【0,7】的count+1

这个例子中，查询的是点而不是区间，如果查询的是区间，那么线段树将是最好的选择。

使用线段树解决问题最重要是要
**根据实际问题想清楚每个节点里面维护哪些信息，以及这些信息如何更高效地维护和查询**。

接下来一篇会介绍高效处理这些信息的一些技巧，包括点更新和延迟更新。

## 其他例题 + 离散化

**例题2**

POJ 3468 A Simple Problem with Integers
给定Q (1 ≤ Q ≤ 100,000)个数A1,A2 … AQ,以及可能多次进行的两个操作:

	1) 对某个区间Ai … Aj的个数都加n(n可变）
	2) 求某个区间Ai … Aj的数的和

本题树节点要存哪些信息？只存该区间的数的和，行不行？

只存和，会导致每次加数的时候都要更新到叶子节点，速度太慢，这是必须要避免的。

本题树节点结构：

	struct CNode
	{
		int L ,R; //区间起点和终点
		CNode * pLeft, * pRight;
		long long nSum; //原来的和
		long long Inc;  //增量c的累加
	}; //本节点区间的和实际上是nSum+Inc*(R-L+1)

在增加时，如果要加的区间正好覆盖一个节点，则增加其节点的Inc值，不再往下走，否则要更新nSum,再将增量往下传在查询时，如果待查区间不是正好覆盖一个节点，就将节点的Inc往下带，然后将Inc代表的所有增量累加到nSum上后将Inc清0，接下来再往下查询。

有时，区间的端点不是整数，或者区间太大导致建树内存开销过大MLE ,那么就需要进行“离散化”后再建树。

**例题3-铺海报**

POJ 2528 Mayor's posters

给定一些海报，可能互相重叠，告诉你每个海报宽度（高度都一样）和先后叠放次序，问没有被完全盖住的海报有多少张。

![图4](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree-Q3P1.png)

海报最多10,000张，但是墙有10,000,000块瓷砖长。海报端点不会落在瓷砖中间。

如果每个叶子节点都代表一块瓷砖，那么线段树会导致MLE，即单位区间的数目太多。实际上，由于最多10,000个海报，共计20,000个端点，这些端点把墙最多分成19,999个区间（题意为整个墙都会被盖到）我们只要对这19,999个区间编号，然后建树即可。这就是**离散化**。

![图4](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree-Q3P2.png)

如果海报端点坐标是浮点数，其实也一样处理。

	struct CNode
	{
		int L,R;
		bool bCovered;
		CNode * pLeft, * pRight;
	};	//bCovered表示本区间是否已经完全被海报盖住
关键： 插入数据的顺序 ------ 从底至上依次插入每张海报

**例题4-矩形覆盖的面积**

给定一些矩形，其顶点坐标是浮点数，可能互相重叠，问这些矩形覆盖到的面积是多大。

![图4](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree-Q4P1.png)

用线段树做，先要离散化！！

在Y轴进行离散化。n个矩形的2n个横边纵坐标共构成最多2n-1个区间的边界，对这些区间编号，建立起线段树。

![图4](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree-Q4P2.png)

线段树的节点要保存哪些信息？如何将一个个矩形插入线段树？插入过程中这些信息如何更新？怎样查询？

	struct CNode
	{
		int L,R;
		CNode * pLeft, * pRight;
		double Len; //落在本区间的线段总长度
		int Covers;//本区间被完全覆盖的重数
	};

上面的“线段”指的是真实的线段，即由矩形的边构成的，不是“区间”的意思

插入数据的顺序：

将矩形的纵边从左到右排序，然后依次将这些纵边插入线段树。要记住哪些纵边是一个矩形的左边(开始边)，哪些纵边是一个矩形的右边（结束边），以便插入时，对Len和Covers做不同的修改。

插入一条边后就更新总覆盖面积的值。

有时，不一定能够一眼看出什么是“区间”，这就要靠仔细观察，造出“区间”来。比如下面这道题目：

**例题5-多少个苹果**

POJ 3321 Apple Tree

每个分叉点及末梢可能有苹果（最多1个），每次可以摘掉一个苹果，或有一个苹果新长出来，随时查询某个分叉点往上的子树里，一共有多少个苹果。

深度优先遍历整个苹果树，为每个节点标记一个开始时间和结束时间（所有时间都不相同），显然子树里面所有节点的开始和结束时间，都位于子树树根的开始和结束时间之间。

问题变成：
有n个节点，就有2n个开始结束时间，它们构成序列A1A2….A2n序列里每个数是0或者1，可变化，随时查询某个区间里数的和。当然由于苹果树上每个放苹果的位置对应于数列里的两个数，所以结果要除以2.

## 树状数组

对于序列a，我们设一个数组C

	C[i] = a[i – 2k + 1] + … + a[i]
	k为i在二进制下末尾0的个数
	i从1开始算！

C即为a的树状数组

对于i,如何求2^k？

2^k =i & (i^(i-1)) 也就是 i & (-i)

以6为例

	(6)10=(0110)2
	xor 6-1=(5)10=(0101)2
	(0011)2
	and (6)10= (0110)2
	(0010)2 = (4)10

通常我们用lowbit(x)表示x对应的 2^k,
lowbit(x) = x&(-x)
lowbit(x) 实际上就是x的二进制表示形式
留下最右边的1，其他位都变成0

**C[i] = a[i-lowbit(i)+1] + …+ a[i]**

C包含哪些项看上去没有规律

	C1=A1
	C2=A1+A2
	C3=A3
	C4=A1+A2+A3+A4
	C5=A5
	C6=A5+A6
	C7=A7
	C8=A1+A2+A3+A4+A5+A6+A7+A8
	…………
	C16=A1+A2+A3+A4+A5+A6+A7+A8+A9+A10+A11+A12+A13+A14+A15+A16

树状数组图示

![图4](https://github.com/vo01github/Data_Structures/raw/master/pic/SegmentTree-treeArray.png)



树状数组的好处在于能快速求任意区间的和 a[i] + a[i+1] + … + a[j]

设sum(k) = a[1]+a[2]+…+a[k]

则 a[i] + a[i+1] + … + a[j] = sum(j)-sum(j-1)

有了树状数组，sum(k)就能在O(logN)时间内求出，N是a数组元素个数。而且更新一个a的元素所花的时间也是O(logN)的(a更新了C也得更新)。

具体分析：
>
http://poj.org/summerschool/1_interval_tree.pdf

所以，树状数组适合单个元素经常修改而且还反复要求部分的区间的和的情况。

上述问题虽然也可以用线段树解决，但是用树状数组来做，编程效率和程序运行效率都更高

如果每次要修改的不是单个元素，而是一个区间，那就不能用树状数组了(效率过低）。

## 优化 和 其他

线段树需要的空间为数组大小的四倍，线段树为什么要开4倍空间？
>
http://scinart.github.io/acm/2014/03/19/acm-segment-tree-space-analysis/

其他例题举例。
>
http://poj.org/summerschool/1_interval_tree.pdf

zkw线段树, 由清华大学的张昆玮提出。
它对于线段树的优化体现在减少了递归操作和增加了位运算等操作以减少常数。
详细资料见讲课资料《统计的力量——线段树全接触》


ZKW线段树详解
>
http://wyfcyx.logdown.com/posts/201802-summary-data-structures-zkw-segment-tree-details
